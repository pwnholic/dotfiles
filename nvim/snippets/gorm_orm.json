{
  "GORM Basic Model": {
    "prefix": "gorm-model",
    "body": [
      "type ${1:User} struct {",
      "\tID        uint           `gorm:\"primaryKey\"`",
      "\tCreatedAt time.Time",
      "\tUpdatedAt time.Time",
      "\tDeletedAt gorm.DeletedAt `gorm:\"index\"`",
      "\t${2:Name}  string         `gorm:\"size:255;not null\"`",
      "\t${3:Email} string         `gorm:\"size:255;uniqueIndex;not null\"`",
      "\t${4:Age}   int            `gorm:\"default:18\"`",
      "}"
    ],
    "description": "Basic GORM model structure"
  },
  "GORM CRUD Operations": {
    "prefix": "gorm-crud",
    "body": [
      "// Create",
      "func Create${1:User}(db *gorm.DB, ${2:user} *${1}) error {",
      "\tresult := db.Create(${2})",
      "\tif result.Error != nil {",
      "\t\treturn fmt.Errorf(\"failed to create ${1}: %w\", result.Error)",
      "\t}",
      "\treturn nil",
      "}",
      "",
      "// Get by ID",
      "func Get${1}ByID(db *gorm.DB, id uint) (*${1}, error) {",
      "\tvar ${2} ${1}",
      "\tresult := db.First(&${2}, id)",
      "\tif result.Error != nil {",
      "\t\tif errors.Is(result.Error, gorm.ErrRecordNotFound) {",
      "\t\t\treturn nil, nil",
      "\t\t}",
      "\t\treturn nil, fmt.Errorf(\"failed to get ${1}: %w\", result.Error)",
      "\t}",
      "\treturn &${2}, nil",
      "}",
      "",
      "// Update",
      "func Update${1}(db *gorm.DB, ${2} *${1}) error {",
      "\tresult := db.Save(${2})",
      "\tif result.Error != nil {",
      "\t\treturn fmt.Errorf(\"failed to update ${1}: %w\", result.Error)",
      "\t}",
      "\treturn nil",
      "}",
      "",
      "// Delete",
      "func Delete${1}(db *gorm.DB, id uint) error {",
      "\tresult := db.Delete(&${1}{}, id)",
      "\tif result.Error != nil {",
      "\t\treturn fmt.Errorf(\"failed to delete ${1}: %w\", result.Error)",
      "\t}",
      "\tif result.RowsAffected == 0 {",
      "\t\treturn fmt.Errorf(\"${1} not found\")",
      "\t}",
      "\treturn nil",
      "}",
      "",
      "// List all with pagination",
      "func List${1}s(db *gorm.DB, page, pageSize int) ([]${1}, int64, error) {",
      "\tvar ${2}s []${1}",
      "\tvar total int64",
      "",
      "\tdb.Model(&${1}{}).Count(&total)",
      "",
      "\tresult := db.Offset((page - 1) * pageSize).Limit(pageSize).Find(&${2}s)",
      "\tif result.Error != nil {",
      "\t\treturn nil, 0, fmt.Errorf(\"failed to list ${1}s: %w\", result.Error)",
      "\t}",
      "",
      "\treturn ${2}s, total, nil",
      "}"
    ],
    "description": "Complete CRUD operations with GORM"
  },
  "GORM Transaction": {
    "prefix": "gorm-tx",
    "body": [
      "err := db.Transaction(func(tx *gorm.DB) error {",
      "\t${1:// Perform database operations}",
      "\tif err := ${2:operation}(tx); err != nil {",
      "\t\treturn err // Rollback if error",
      "\t}",
      "",
      "\t${3:// Another operation}",
      "\tif err := ${4:anotherOperation}(tx); err != nil {",
      "\t\treturn err",
      "\t}",
      "",
      "\treturn nil // Commit if no error",
      "})",
      "",
      "if err != nil {",
      "\t${5:// Handle error}",
      "}"
    ],
    "description": "GORM database transaction"
  },
  "GORM Hooks": {
    "prefix": "gorm-hooks",
    "body": [
      "// BeforeCreate hook",
      "func (${1:u} *${2:User}) BeforeCreate(tx *gorm.DB) error {",
      "\t${1}.${3:UUID} = uuid.New().String()",
      "\t${1}.${4:Password} = hashPassword(${1}.${4:Password})",
      "\treturn nil",
      "}",
      "",
      "// BeforeUpdate hook",
      "func (${1} *${2}) BeforeUpdate(tx *gorm.DB) error {",
      "\t${1}.${5:UpdatedAt} = time.Now()",
      "\tif tx.Statement.Changed(\"${4:Password}\") {",
      "\t\t${1}.${4} = hashPassword(${1}.${4})",
      "\t}",
      "\treturn nil",
      "}",
      "",
      "// AfterFind hook",
      "func (${1} *${2}) AfterFind(tx *gorm.DB) error {",
      "\t${1}.${6:DisplayName} = fmt.Sprintf(\"%s %s\", ${1}.${7:FirstName}, ${1}.${8:LastName})",
      "\treturn nil",
      "}"
    ],
    "description": "GORM model hooks"
  },
  "GORM Associations": {
    "prefix": "gorm-assoc",
    "body": [
      "// ${1:User} has many ${2:Posts}",
      "type ${1} struct {",
      "\tgorm.Model",
      "\t${2} []${2} `gorm:\"foreignKey:${1}ID\"`",
      "}",
      "",
      "type ${2} struct {",
      "\tgorm.Model",
      "\tTitle   string",
      "\tContent string",
      "\t${1}ID  uint",
      "}",
      "",
      "// Create with association",
      "func Create${1}With${2}s(db *gorm.DB, ${3:user} *${1}) error {",
      "\treturn db.Create(${3}).Error",
      "}",
      "",
      "// Preload associations",
      "func Get${1}With${2}s(db *gorm.DB, id uint) (*${1}, error) {",
      "\tvar ${3} ${1}",
      "\terr := db.Preload(\"${2}\").First(&${3}, id).Error",
      "\tif err != nil {",
      "\t\treturn nil, err",
      "\t}",
      "\treturn &${3}, nil",
      "}",
      "",
      "// Append to association",
      "func Add${2}To${1}(db *gorm.DB, ${1}ID uint, ${4:post} *${2}) error {",
      "\treturn db.Model(&${1}{ID: ${1}ID}).Association(\"${2}\").Append(${4})",
      "}"
    ],
    "description": "GORM model associations"
  },
  "GORM Soft Delete": {
    "prefix": "gorm-soft-delete",
    "body": [
      "// Model with soft delete",
      "type ${1:User} struct {",
      "\tgorm.Model",
      "\t${2:Name} string",
      "}",
      "",
      "// Soft delete",
      "func Delete${1}(db *gorm.DB, id uint) error {",
      "\tresult := db.Delete(&${1}{}, id)",
      "\treturn result.Error",
      "}",
      "",
      "// Find including soft deleted",
      "func Get${1}WithDeleted(db *gorm.DB, id uint) (*${1}, error) {",
      "\tvar ${3:user} ${1}",
      "\terr := db.Unscoped().Where(\"id = ?\", id).First(&${3}).Error",
      "\treturn &${3}, err",
      "}",
      "",
      "// Permanent delete",
      "func HardDelete${1}(db *gorm.DB, id uint) error {",
      "\tresult := db.Unscoped().Delete(&${1}{}, id)",
      "\treturn result.Error",
      "}",
      "",
      "// Restore soft deleted",
      "func Restore${1}(db *gorm.DB, id uint) error {",
      "\tresult := db.Unscoped().Model(&${1}{}).Where(\"id = ?\", id).Update(\"deleted_at\", nil)",
      "\treturn result.Error",
      "}"
    ],
    "description": "GORM soft delete operations"
  },
  "GORM Raw SQL": {
    "prefix": "gorm-raw",
    "body": [
      "// Execute raw SQL",
      "func ${1:GetUsersByRole}(db *gorm.DB, ${2:role} string) ([]${3:User}, error) {",
      "\tvar ${4:users} []${3}",
      "\terr := db.Raw(\"SELECT * FROM ${5:users} WHERE ${6:role} = ?\", ${2}).Scan(&${4}).Error",
      "\tif err != nil {",
      "\t\treturn nil, fmt.Errorf(\"failed to execute query: %w\", err)",
      "\t}",
      "\treturn ${4}, nil",
      "}",
      "",
      "// Exec with parameters",
      "func ${7:UpdateUserStatus}(db *gorm.DB, ${8:userID} uint, ${9:status} string) error {",
      "\tresult := db.Exec(",
      "\t\t\"UPDATE ${5} SET status = ? WHERE id = ?\", ${9}, ${8}",
      "\t)",
      "\tif result.Error != nil {",
      "\t\treturn fmt.Errorf(\"failed to update: %w\", result.Error)",
      "\t}",
      "\tif result.RowsAffected == 0 {",
      "\t\treturn fmt.Errorf(\"no rows affected\")",
      "\t}",
      "\treturn nil",
      "}"
    ],
    "description": "GORM raw SQL operations"
  },
  "GORM Pagination": {
    "prefix": "gorm-paginate",
    "body": [
      "type ${1:Pagination} struct {",
      "\tPage      int",
      "\tPageSize  int",
      "\tTotal     int64",
      "\tTotalPage int",
      "\tData      interface{}",
      "}",
      "",
      "func ${2:Paginate}(db *gorm.DB, model interface{}, page, pageSize int) (*${1}, error) {",
      "\tvar total int64",
      "\tdb.Model(model).Count(&total)",
      "",
      "\ttotalPage := int(math.Ceil(float64(total) / float64(pageSize)))",
      "\tif page < 1 {",
      "\t\tpage = 1",
      "\t}",
      "\tif page > totalPage {",
      "\t\tpage = totalPage",
      "\t}",
      "",
      "\toffset := (page - 1) * pageSize",
      "\terr := db.Offset(offset).Limit(pageSize).Find(model).Error",
      "\tif err != nil {",
      "\t\treturn nil, err",
      "\t}",
      "",
      "\treturn &${1}{",
      "\t\tPage:      page,",
      "\t\tPageSize:  pageSize,",
      "\t\tTotal:     total,",
      "\t\tTotalPage: totalPage,",
      "\t\tData:      model,",
      "\t}, nil",
      "}"
    ],
    "description": "Generic pagination with GORM"
  },
  "GORM Connection Pool": {
    "prefix": "gorm-pool",
    "body": [
      "func ${1:InitDB}() (*gorm.DB, error) {",
      "\tdsn := fmt.Sprintf(",
      "\t\t\"%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local\",",
      "\t\tos.Getenv(\"DB_USER\"),",
      "\t\tos.Getenv(\"DB_PASSWORD\"),",
      "\t\tos.Getenv(\"DB_HOST\"),",
      "\t\tos.Getenv(\"DB_PORT\"),",
      "\t\tos.Getenv(\"DB_NAME\"),",
      "\t)",
      "",
      "\tdb, err := gorm.Open(mysql.Open(dsn), &gorm.Config{",
      "\t\tLogger: logger.Default.LogMode(logger.${2:Info}),",
      "\t})",
      "\tif err != nil {",
      "\t\treturn nil, fmt.Errorf(\"failed to connect database: %w\", err)",
      "\t}",
      "",
      "\tsqlDB, err := db.DB()",
      "\tif err != nil {",
      "\t\treturn nil, fmt.Errorf(\"failed to get sql.DB: %w\", err)",
      "\t}",
      "",
      "\t// Connection pool settings",
      "\tsqlDB.SetMaxIdleConns(${3:10})",
      "\tsqlDB.SetMaxOpenConns(${4:100})",
      "\tsqlDB.SetConnMaxLifetime(${5:time.Hour})",
      "\tsqlDB.SetConnMaxIdleTime(${6:10 * time.Minute})",
      "",
      "\t// Auto migrate",
      "\terr = db.AutoMigrate(",
      "\t\t&${7:User}{},",
      "\t\t&${8:Post}{},",
      "\t)",
      "\tif err != nil {",
      "\t\treturn nil, fmt.Errorf(\"failed to auto migrate: %w\", err)",
      "\t}",
      "",
      "\treturn db, nil",
      "}"
    ],
    "description": "GORM database initialization with connection pool"
  }
}
